[
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 444,
    "end_line": 481,
    "length": 38,
    "content": "// Per-CPU process scheduler.\n// Each CPU calls scheduler() after setting itself up.\n// Scheduler never returns.  It loops, doing:\n//  - choose a process to run.\n//  - swtch to start running that process.\n//  - eventually that process transfers control\n//    via swtch back to the scheduler.\nvoid\nscheduler(void)\n{\n  struct proc *p;\n  struct cpu *c = mycpu();\n\n  c->proc = 0;\n  for(;;){\n    // The most recent process to run may have had interrupts\n    // turned off; enable them to avoid a deadlock if all\n    // processes are waiting.\n    intr_on();\n\n    int found = 0;\n    for(p = proc; p < &proc[NPROC]; p++) {\n      acquire(&p->lock);\n      if(p->state == RUNNABLE) {\n        // Switch to chosen process.  It is the process's job\n        // to release its lock and then reacquire it\n        // before jumping back to us.\n        p->state = RUNNING;\n        c->proc = p;\n        swtch(&c->context, &p->context);\n\n        // Process is done running for now.\n        // It should have changed its p->state before coming back.\n        c->proc = 0;\n        found = 1;\n      }\n      release(&p->lock);\n    }\n    if(found == 0) {\n      // nothing to run; stop running on this core until an interrupt.\n      intr_on();\n      asm volatile(\"wfi\");\n    }\n  }\n}"
  },
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 390,
    "end_line": 435,
    "length": 46,
    "content": "// Wait for a child process to exit and return its pid.\n// Return -1 if this process has no children.\nint\nwait(uint64 addr)\n{\n  struct proc *pp;\n  int havekids, pid;\n  struct proc *p = myproc();\n\n  acquire(&wait_lock);\n\n  for(;;){\n    // Scan through table looking for exited children.\n    havekids = 0;\n    for(pp = proc; pp < &proc[NPROC]; pp++){\n      if(pp->parent == p){\n        // make sure the child isn't still in exit() or swtch().\n        acquire(&pp->lock);\n\n        havekids = 1;\n        if(pp->state == ZOMBIE){\n          // Found one.\n          pid = pp->pid;\n          if(addr != 0 && copyout(p->pagetable, addr, (char *)&pp->xstate,\n                                 sizeof(pp->xstate)) < 0) {\n            release(&pp->lock);\n            release(&wait_lock);\n            return -1;\n          }\n          freeproc(pp);\n          release(&pp->lock);\n          release(&wait_lock);\n          return pid;\n        }\n        release(&pp->lock);\n      }\n    }\n\n    // No point waiting if we don't have any children.\n    if(!havekids || killed(p)){\n      release(&wait_lock);\n      return -1;\n    }\n    \n    // Wait for a child to exit.\n    sleep(p, &wait_lock);  //DOC: wait-sleep\n  }\n}"
  },
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 578,
    "end_line": 592,
    "length": 15,
    "content": "// Wake up all processes sleeping on chan.\n// Must be called without any p->lock.\nvoid\nwakeup(void *chan)\n{\n  struct proc *p;\n\n  for(p = proc; p < &proc[NPROC]; p++) {\n    if(p != myproc()){\n      acquire(&p->lock);\n      if(p->state == SLEEPING && p->chan == chan) {\n        p->state = RUNNABLE;\n      }\n      release(&p->lock);\n    }\n  }\n}"
  },
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 597,
    "end_line": 616,
    "length": 20,
    "content": "// Kill the process with the given pid.\n// The victim won't exit until it tries to return\n// to user space (see usertrap() in trap.c).\nint\nkill(int pid)\n{\n  struct proc *p;\n\n  for(p = proc; p < &proc[NPROC]; p++){\n    acquire(&p->lock);\n    if(p->pid == pid){\n      p->killed = 1;\n      if(p->state == SLEEPING){\n        // Wake process from sleep().\n        p->state = RUNNABLE;\n      }\n      release(&p->lock);\n      return 0;\n    }\n    release(&p->lock);\n  }\n  return -1;\n}"
  },
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 109,
    "end_line": 123,
    "length": 15,
    "content": "// Look in the process table for an UNUSED proc.\n// If found, initialize state required to run in the kernel,\n// and return with p->lock held.\n// If there are no free procs, or a memory allocation fails, return 0.\nstatic struct proc*\nallocproc(void)\n{\n  struct proc *p;\n\n  for(p = proc; p < &proc[NPROC]; p++) {\n    acquire(&p->lock);\n    if(p->state == UNUSED) {\n      goto found;\n    } else {\n      release(&p->lock);\n    }\n  }\n  return 0;"
  },
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 330,
    "end_line": 341,
    "length": 12,
    "content": "// Pass p's abandoned children to init.\n// Caller must hold wait_lock.\nvoid\nreparent(struct proc *p)\n{\n  struct proc *pp;\n\n  for(pp = proc; pp < &proc[NPROC]; pp++){\n    if(pp->parent == p){\n      pp->parent = initproc;\n      wakeup(initproc);\n    }\n  }\n}"
  },
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 47,
    "end_line": 59,
    "length": 13,
    "content": "// initialize the proc table.\nvoid\nprocinit(void)\n{\n  struct proc *p;\n  \n  initlock(&pid_lock, \"nextpid\");\n  initlock(&wait_lock, \"wait_lock\");\n  for(p = proc; p < &proc[NPROC]; p++) {\n      initlock(&p->lock, \"proc\");\n      p->state = UNUSED;\n      p->kstack = KSTACK((int) (p - proc));\n  }\n}"
  },
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 670,
    "end_line": 695,
    "length": 26,
    "content": "// Print a process listing to console.  For debugging.\n// Runs when user types ^P on console.\n// No lock to avoid wedging a stuck machine further.\nvoid\nprocdump(void)\n{\n  static char *states[] = {\n  [UNUSED]    \"unused\",\n  [USED]      \"used\",\n  [SLEEPING]  \"sleep \",\n  [RUNNABLE]  \"runble\",\n  [RUNNING]   \"run   \",\n  [ZOMBIE]    \"zombie\"\n  };\n  struct proc *p;\n  char *state;\n\n  printf(\"\\n\");\n  for(p = proc; p < &proc[NPROC]; p++){\n    if(p->state == UNUSED)\n      continue;\n    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])\n      state = states[p->state];\n    else\n      state = \"???\";\n    printf(\"%d %s %s\", p->pid, state, p->name);\n    printf(\"\\n\");\n  }\n}"
  },
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 32,
    "end_line": 44,
    "length": 13,
    "content": "// Allocate a page for each process's kernel stack.\n// Map it high in memory, followed by an invalid\n// guard page.\nvoid\nproc_mapstacks(pagetable_t kpgtbl)\n{\n  struct proc *p;\n  \n  for(p = proc; p < &proc[NPROC]; p++) {\n    char *pa = kalloc();\n    if(pa == 0)\n      panic(\"kalloc\");\n    uint64 va = KSTACK((int) (p - proc));\n    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);\n  }\n}"
  },
  {
    "filepath": "/Users/benson/Local/cs486-686/inclass/week06/llama-index/xv6-riscv/kernel/proc.c",
    "filename": "proc.c",
    "relpath": "kernel/proc.c",
    "start_line": 11,
    "end_line": 11,
    "length": 1,
    "content": "struct proc proc[NPROC];"
  }
]